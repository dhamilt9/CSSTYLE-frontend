{"ast":null,"code":"/* -*- Mode: js; js-indent-level: 2; -*- */\n\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nif (typeof define !== 'function') {\n  var define = require('amdefine')(module, require);\n}\n\ndefine(function (require, exports, module) {\n  var util = require('./util');\n\n  var binarySearch = require('./binary-search');\n\n  var ArraySet = require('./array-set').ArraySet;\n\n  var base64VLQ = require('./base64-vlq');\n  /**\n   * A SourceMapConsumer instance represents a parsed source map which we can\n   * query for information about the original file positions by giving it a file\n   * position in the generated source.\n   *\n   * The only parameter is the raw source map (either as a JSON string, or\n   * already parsed to an object). According to the spec, source maps have the\n   * following attributes:\n   *\n   *   - version: Which version of the source map spec this map is following.\n   *   - sources: An array of URLs to the original source files.\n   *   - names: An array of identifiers which can be referrenced by individual mappings.\n   *   - sourceRoot: Optional. The URL root from which all sources are relative.\n   *   - sourcesContent: Optional. An array of contents of the original source files.\n   *   - mappings: A string of base64 VLQs which contain the actual mappings.\n   *   - file: Optional. The generated file this source map is associated with.\n   *\n   * Here is an example source map, taken from the source map spec[0]:\n   *\n   *     {\n   *       version : 3,\n   *       file: \"out.js\",\n   *       sourceRoot : \"\",\n   *       sources: [\"foo.js\", \"bar.js\"],\n   *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n   *       mappings: \"AA,AB;;ABCDE;\"\n   *     }\n   *\n   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n   */\n\n\n  function SourceMapConsumer(aSourceMap) {\n    var sourceMap = aSourceMap;\n\n    if (typeof aSourceMap === 'string') {\n      sourceMap = JSON.parse(aSourceMap.replace(/^\\)\\]\\}'/, ''));\n    }\n\n    var version = util.getArg(sourceMap, 'version');\n    var sources = util.getArg(sourceMap, 'sources'); // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n    // requires the array) to play nice here.\n\n    var names = util.getArg(sourceMap, 'names', []);\n    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);\n    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);\n    var mappings = util.getArg(sourceMap, 'mappings');\n    var file = util.getArg(sourceMap, 'file', null); // Once again, Sass deviates from the spec and supplies the version as a\n    // string rather than a number, so we use loose equality checking here.\n\n    if (version != this._version) {\n      throw new Error('Unsupported version: ' + version);\n    } // Some source maps produce relative source paths like \"./foo.js\" instead of\n    // \"foo.js\".  Normalize these first so that future comparisons will succeed.\n    // See bugzil.la/1090768.\n\n\n    sources = sources.map(util.normalize); // Pass `true` below to allow duplicate names and sources. While source maps\n    // are intended to be compressed and deduplicated, the TypeScript compiler\n    // sometimes generates source maps with duplicates in them. See Github issue\n    // #72 and bugzil.la/889492.\n\n    this._names = ArraySet.fromArray(names, true);\n    this._sources = ArraySet.fromArray(sources, true);\n    this.sourceRoot = sourceRoot;\n    this.sourcesContent = sourcesContent;\n    this._mappings = mappings;\n    this.file = file;\n  }\n  /**\n   * Create a SourceMapConsumer from a SourceMapGenerator.\n   *\n   * @param SourceMapGenerator aSourceMap\n   *        The source map that will be consumed.\n   * @returns SourceMapConsumer\n   */\n\n\n  SourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {\n    var smc = Object.create(SourceMapConsumer.prototype);\n    smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);\n    smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);\n    smc.sourceRoot = aSourceMap._sourceRoot;\n    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);\n    smc.file = aSourceMap._file;\n    smc.__generatedMappings = aSourceMap._mappings.toArray().slice();\n    smc.__originalMappings = aSourceMap._mappings.toArray().slice().sort(util.compareByOriginalPositions);\n    return smc;\n  };\n  /**\n   * The version of the source mapping spec that we are consuming.\n   */\n\n\n  SourceMapConsumer.prototype._version = 3;\n  /**\n   * The list of original sources.\n   */\n\n  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {\n    get: function get() {\n      return this._sources.toArray().map(function (s) {\n        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;\n      }, this);\n    }\n  }); // `__generatedMappings` and `__originalMappings` are arrays that hold the\n  // parsed mapping coordinates from the source map's \"mappings\" attribute. They\n  // are lazily instantiated, accessed via the `_generatedMappings` and\n  // `_originalMappings` getters respectively, and we only parse the mappings\n  // and create these arrays once queried for a source location. We jump through\n  // these hoops because there can be many thousands of mappings, and parsing\n  // them is expensive, so we only want to do it if we must.\n  //\n  // Each object in the arrays is of the form:\n  //\n  //     {\n  //       generatedLine: The line number in the generated code,\n  //       generatedColumn: The column number in the generated code,\n  //       source: The path to the original source file that generated this\n  //               chunk of code,\n  //       originalLine: The line number in the original source that\n  //                     corresponds to this chunk of generated code,\n  //       originalColumn: The column number in the original source that\n  //                       corresponds to this chunk of generated code,\n  //       name: The name of the original symbol which generated this chunk of\n  //             code.\n  //     }\n  //\n  // All properties except for `generatedLine` and `generatedColumn` can be\n  // `null`.\n  //\n  // `_generatedMappings` is ordered by the generated positions.\n  //\n  // `_originalMappings` is ordered by the original positions.\n\n  SourceMapConsumer.prototype.__generatedMappings = null;\n  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {\n    get: function get() {\n      if (!this.__generatedMappings) {\n        this.__generatedMappings = [];\n        this.__originalMappings = [];\n\n        this._parseMappings(this._mappings, this.sourceRoot);\n      }\n\n      return this.__generatedMappings;\n    }\n  });\n  SourceMapConsumer.prototype.__originalMappings = null;\n  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {\n    get: function get() {\n      if (!this.__originalMappings) {\n        this.__generatedMappings = [];\n        this.__originalMappings = [];\n\n        this._parseMappings(this._mappings, this.sourceRoot);\n      }\n\n      return this.__originalMappings;\n    }\n  });\n\n  SourceMapConsumer.prototype._nextCharIsMappingSeparator = function SourceMapConsumer_nextCharIsMappingSeparator(aStr) {\n    var c = aStr.charAt(0);\n    return c === \";\" || c === \",\";\n  };\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n\n\n  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {\n    var generatedLine = 1;\n    var previousGeneratedColumn = 0;\n    var previousOriginalLine = 0;\n    var previousOriginalColumn = 0;\n    var previousSource = 0;\n    var previousName = 0;\n    var str = aStr;\n    var temp = {};\n    var mapping;\n\n    while (str.length > 0) {\n      if (str.charAt(0) === ';') {\n        generatedLine++;\n        str = str.slice(1);\n        previousGeneratedColumn = 0;\n      } else if (str.charAt(0) === ',') {\n        str = str.slice(1);\n      } else {\n        mapping = {};\n        mapping.generatedLine = generatedLine; // Generated column.\n\n        base64VLQ.decode(str, temp);\n        mapping.generatedColumn = previousGeneratedColumn + temp.value;\n        previousGeneratedColumn = mapping.generatedColumn;\n        str = temp.rest;\n\n        if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {\n          // Original source.\n          base64VLQ.decode(str, temp);\n          mapping.source = this._sources.at(previousSource + temp.value);\n          previousSource += temp.value;\n          str = temp.rest;\n\n          if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {\n            throw new Error('Found a source, but no line and column');\n          } // Original line.\n\n\n          base64VLQ.decode(str, temp);\n          mapping.originalLine = previousOriginalLine + temp.value;\n          previousOriginalLine = mapping.originalLine; // Lines are stored 0-based\n\n          mapping.originalLine += 1;\n          str = temp.rest;\n\n          if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {\n            throw new Error('Found a source and line, but no column');\n          } // Original column.\n\n\n          base64VLQ.decode(str, temp);\n          mapping.originalColumn = previousOriginalColumn + temp.value;\n          previousOriginalColumn = mapping.originalColumn;\n          str = temp.rest;\n\n          if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {\n            // Original name.\n            base64VLQ.decode(str, temp);\n            mapping.name = this._names.at(previousName + temp.value);\n            previousName += temp.value;\n            str = temp.rest;\n          }\n        }\n\n        this.__generatedMappings.push(mapping);\n\n        if (typeof mapping.originalLine === 'number') {\n          this.__originalMappings.push(mapping);\n        }\n      }\n    }\n\n    this.__generatedMappings.sort(util.compareByGeneratedPositions);\n\n    this.__originalMappings.sort(util.compareByOriginalPositions);\n  };\n  /**\n   * Find the mapping that best matches the hypothetical \"needle\" mapping that\n   * we are searching for in the given \"haystack\" of mappings.\n   */\n\n\n  SourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator) {\n    // To return the position we are searching for, we must first find the\n    // mapping for the given position and then return the opposite position it\n    // points to. Because the mappings are sorted, we can use binary search to\n    // find the best mapping.\n    if (aNeedle[aLineName] <= 0) {\n      throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);\n    }\n\n    if (aNeedle[aColumnName] < 0) {\n      throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);\n    }\n\n    return binarySearch.search(aNeedle, aMappings, aComparator);\n  };\n  /**\n   * Compute the last column for each generated mapping. The last column is\n   * inclusive.\n   */\n\n\n  SourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {\n    for (var index = 0; index < this._generatedMappings.length; ++index) {\n      var mapping = this._generatedMappings[index]; // Mappings do not contain a field for the last generated columnt. We\n      // can come up with an optimistic estimate, however, by assuming that\n      // mappings are contiguous (i.e. given two consecutive mappings, the\n      // first mapping ends where the second one starts).\n\n      if (index + 1 < this._generatedMappings.length) {\n        var nextMapping = this._generatedMappings[index + 1];\n\n        if (mapping.generatedLine === nextMapping.generatedLine) {\n          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;\n          continue;\n        }\n      } // The last mapping for each line spans the entire line.\n\n\n      mapping.lastGeneratedColumn = Infinity;\n    }\n  };\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.\n   *   - column: The column number in the generated source.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.\n   *   - column: The column number in the original source, or null.\n   *   - name: The original identifier, or null.\n   */\n\n\n  SourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {\n    var needle = {\n      generatedLine: util.getArg(aArgs, 'line'),\n      generatedColumn: util.getArg(aArgs, 'column')\n    };\n\n    var index = this._findMapping(needle, this._generatedMappings, \"generatedLine\", \"generatedColumn\", util.compareByGeneratedPositions);\n\n    if (index >= 0) {\n      var mapping = this._generatedMappings[index];\n\n      if (mapping.generatedLine === needle.generatedLine) {\n        var source = util.getArg(mapping, 'source', null);\n\n        if (source != null && this.sourceRoot != null) {\n          source = util.join(this.sourceRoot, source);\n        }\n\n        return {\n          source: source,\n          line: util.getArg(mapping, 'originalLine', null),\n          column: util.getArg(mapping, 'originalColumn', null),\n          name: util.getArg(mapping, 'name', null)\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null\n    };\n  };\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * availible.\n   */\n\n\n  SourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    if (this.sourceRoot != null) {\n      aSource = util.relative(this.sourceRoot, aSource);\n    }\n\n    if (this._sources.has(aSource)) {\n      return this.sourcesContent[this._sources.indexOf(aSource)];\n    }\n\n    var url;\n\n    if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {\n      // XXX: file:// URIs and absolute paths lead to unexpected behavior for\n      // many users. We can help them out when they expect file:// URIs to\n      // behave like it would if they were running a local HTTP server. See\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.\n      var fileUriAbsPath = aSource.replace(/^file:\\/\\//, \"\");\n\n      if (url.scheme == \"file\" && this._sources.has(fileUriAbsPath)) {\n        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];\n      }\n\n      if ((!url.path || url.path == \"/\") && this._sources.has(\"/\" + aSource)) {\n        return this.sourcesContent[this._sources.indexOf(\"/\" + aSource)];\n      }\n    }\n\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  };\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.\n   *   - column: The column number in the original source.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.\n   *   - column: The column number in the generated source, or null.\n   */\n\n\n  SourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: util.getArg(aArgs, 'column')\n    };\n\n    if (this.sourceRoot != null) {\n      needle.source = util.relative(this.sourceRoot, needle.source);\n    }\n\n    var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions);\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n      return {\n        line: util.getArg(mapping, 'generatedLine', null),\n        column: util.getArg(mapping, 'generatedColumn', null),\n        lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n      };\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null\n    };\n  };\n  /**\n   * Returns all generated line and column information for the original source\n   * and line provided. The only argument is an object with the following\n   * properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.\n   *\n   * and an array of objects is returned, each with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.\n   *   - column: The column number in the generated source, or null.\n   */\n\n\n  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {\n    // When there is no exact match, SourceMapConsumer.prototype._findMapping\n    // returns the index of the closest mapping less than the needle. By\n    // setting needle.originalColumn to Infinity, we thus find the last\n    // mapping for the given line, provided such a mapping exists.\n    var needle = {\n      source: util.getArg(aArgs, 'source'),\n      originalLine: util.getArg(aArgs, 'line'),\n      originalColumn: Infinity\n    };\n\n    if (this.sourceRoot != null) {\n      needle.source = util.relative(this.sourceRoot, needle.source);\n    }\n\n    var mappings = [];\n\n    var index = this._findMapping(needle, this._originalMappings, \"originalLine\", \"originalColumn\", util.compareByOriginalPositions);\n\n    if (index >= 0) {\n      var mapping = this._originalMappings[index];\n\n      while (mapping && mapping.originalLine === needle.originalLine) {\n        mappings.push({\n          line: util.getArg(mapping, 'generatedLine', null),\n          column: util.getArg(mapping, 'generatedColumn', null),\n          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)\n        });\n        mapping = this._originalMappings[--index];\n      }\n    }\n\n    return mappings.reverse();\n  };\n\n  SourceMapConsumer.GENERATED_ORDER = 1;\n  SourceMapConsumer.ORIGINAL_ORDER = 2;\n  /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */\n\n  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {\n    var context = aContext || null;\n    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n    var mappings;\n\n    switch (order) {\n      case SourceMapConsumer.GENERATED_ORDER:\n        mappings = this._generatedMappings;\n        break;\n\n      case SourceMapConsumer.ORIGINAL_ORDER:\n        mappings = this._originalMappings;\n        break;\n\n      default:\n        throw new Error(\"Unknown order of iteration.\");\n    }\n\n    var sourceRoot = this.sourceRoot;\n    mappings.map(function (mapping) {\n      var source = mapping.source;\n\n      if (source != null && sourceRoot != null) {\n        source = util.join(sourceRoot, source);\n      }\n\n      return {\n        source: source,\n        generatedLine: mapping.generatedLine,\n        generatedColumn: mapping.generatedColumn,\n        originalLine: mapping.originalLine,\n        originalColumn: mapping.originalColumn,\n        name: mapping.name\n      };\n    }).forEach(aCallback, context);\n  };\n\n  exports.SourceMapConsumer = SourceMapConsumer;\n});","map":null,"metadata":{},"sourceType":"script"}