{"ast":null,"code":"var Result = require('./result');\n\nvar mozilla = require('source-map');\n\nvar Base64 = require('js-base64').Base64;\n\nvar path = require('path'); // All tools to generate source maps\n\n\nvar MapGenerator = function () {\n  var DP$0 = Object.defineProperty;\n  \"use strict\";\n\n  function MapGenerator(root, opts) {\n    this.root = root;\n    this.opts = opts;\n    this.mapOpts = opts.map || {};\n  }\n\n  DP$0(MapGenerator, \"prototype\", {\n    \"configurable\": false,\n    \"enumerable\": false,\n    \"writable\": false\n  }); // Should map be generated\n\n  MapGenerator.prototype.isMap = function () {\n    if (typeof this.opts.map != 'undefined') {\n      return !!this.opts.map;\n    } else {\n      return this.previous().length > 0;\n    }\n  }; // Return source map arrays from previous compilation step (like Sass)\n\n\n  MapGenerator.prototype.previous = function () {\n    var this$0 = this;\n\n    if (!this.previousMaps) {\n      this.previousMaps = [];\n      this.root.eachInside(function (node) {\n        if (node.source && node.source.map) {\n          if (this$0.previousMaps.indexOf(node.source.map) == -1) {\n            this$0.previousMaps.push(node.source.map);\n          }\n        }\n      });\n    }\n\n    return this.previousMaps;\n  }; // Should we inline source map to annotation comment\n\n\n  MapGenerator.prototype.isInline = function () {\n    if (typeof this.mapOpts.inline != 'undefined') {\n      return this.mapOpts.inline;\n    }\n\n    return this.previous().some(function (i) {\n      return i.inline;\n    });\n  }; // Should we set sourcesContent\n\n\n  MapGenerator.prototype.isSourcesContent = function () {\n    if (typeof this.mapOpts.sourcesContent != 'undefined') {\n      return this.mapOpts.sourcesContent;\n    }\n\n    return this.previous().some(function (i) {\n      return i.withContent();\n    });\n  }; // Clear source map annotation comment\n\n\n  MapGenerator.prototype.clearAnnotation = function () {\n    var last = this.root.last;\n    if (!last) return;\n    if (last.type != 'comment') return;\n\n    if (last.text.match(/^# sourceMappingURL=/)) {\n      last.removeSelf();\n    }\n  }; // Set origin CSS content\n\n\n  MapGenerator.prototype.setSourcesContent = function () {\n    var this$0 = this;\n    var already = {};\n    this.root.eachInside(function (node) {\n      var file = node.source.file || node.source.id;\n\n      if (node.source && !already[file]) {\n        already[file] = true;\n        var relative = this$0.relative(file);\n        this$0.map.setSourceContent(relative, node.source.content);\n      }\n    });\n  }; // Apply source map from previous compilation step (like Sass)\n\n\n  MapGenerator.prototype.applyPrevMaps = function () {\n    var S_ITER$0 = typeof Symbol !== 'undefined' && Symbol.iterator || '@@iterator';\n\n    function GET_ITER$0(v) {\n      if (v) {\n        if (Array.isArray(v)) return 0;\n        var f;\n        if (typeof v === 'object' && typeof (f = v[S_ITER$0]) === 'function') return f.call(v);\n        if (v + '' === '[object Generator]') return v;\n      }\n\n      throw new Error(v + ' is not iterable');\n    }\n\n    ;\n    var $D$0;\n    var $D$1;\n    var $D$2;\n    var $D$3;\n    $D$3 = this.previous();\n    $D$0 = GET_ITER$0($D$3);\n    $D$2 = $D$0 === 0;\n    $D$1 = $D$2 ? $D$3.length : void 0;\n\n    for (var prev; $D$2 ? $D$0 < $D$1 : !($D$1 = $D$0[\"next\"]())[\"done\"];) {\n      prev = $D$2 ? $D$3[$D$0++] : $D$1[\"value\"];\n      var from = this.relative(prev.file);\n      var root = prev.root || path.dirname(prev.file);\n      var map;\n\n      if (this.mapOpts.sourcesContent === false) {\n        map = new mozilla.SourceMapConsumer(prev.text);\n        map.sourcesContent = map.sourcesContent.map(function (i) {\n          return null;\n        });\n      } else {\n        map = prev.consumer();\n      }\n\n      this.map.applySourceMap(map, from, this.relative(root));\n    }\n\n    ;\n    $D$0 = $D$1 = $D$2 = $D$3 = void 0;\n  }; // Should we add annotation comment\n\n\n  MapGenerator.prototype.isAnnotation = function () {\n    if (this.isInline()) {\n      return true;\n    } else if (typeof this.mapOpts.annotation != 'undefined') {\n      return this.mapOpts.annotation;\n    } else if (this.previous().length) {\n      return this.previous().some(function (i) {\n        return i.annotation;\n      });\n    } else {\n      return true;\n    }\n  }; // Add source map annotation comment if it is needed\n\n\n  MapGenerator.prototype.addAnnotation = function () {\n    var content;\n\n    if (this.isInline()) {\n      content = \"data:application/json;base64,\" + Base64.encode(this.map.toString());\n    } else if (typeof this.mapOpts.annotation == 'string') {\n      content = this.mapOpts.annotation;\n    } else {\n      content = this.outputFile() + '.map';\n    }\n\n    this.css += \"\\n/*# sourceMappingURL=\" + content + \" */\";\n  }; // Return output CSS file path\n\n\n  MapGenerator.prototype.outputFile = function () {\n    return this.opts.to ? this.relative(this.opts.to) : 'to.css';\n  }; // Return Result object with map\n\n\n  MapGenerator.prototype.generateMap = function () {\n    this.stringify();\n    if (this.isSourcesContent()) this.setSourcesContent();\n    if (this.previous().length > 0) this.applyPrevMaps();\n    if (this.isAnnotation()) this.addAnnotation();\n\n    if (this.isInline()) {\n      return [this.css];\n    } else {\n      return [this.css, this.map];\n    }\n  }; // Return path relative from output CSS file\n\n\n  MapGenerator.prototype.relative = function (file) {\n    var from = this.opts.to ? path.dirname(this.opts.to) : '.';\n\n    if (typeof this.mapOpts.annotation == 'string') {\n      from = path.dirname(path.resolve(from, this.mapOpts.annotation));\n    }\n\n    file = path.relative(from, file);\n\n    if (path.sep == '\\\\') {\n      return file.replace('\\\\', '/');\n    } else {\n      return file;\n    }\n  }; // Return path of node source for map\n\n\n  MapGenerator.prototype.sourcePath = function (node) {\n    return this.relative(node.source.file || node.source.id);\n  }; // Return CSS string and source map\n\n\n  MapGenerator.prototype.stringify = function () {\n    var this$0 = this;\n    this.css = '';\n    this.map = new mozilla.SourceMapGenerator({\n      file: this.outputFile()\n    });\n    var line = 1;\n    var column = 1;\n    var lines, last;\n\n    var builder = function builder(str, node, type) {\n      this$0.css += str;\n\n      if (node && node.source && node.source.start && type != 'end') {\n        this$0.map.addMapping({\n          source: this$0.sourcePath(node),\n          original: {\n            line: node.source.start.line,\n            column: node.source.start.column - 1\n          },\n          generated: {\n            line: line,\n            column: column - 1\n          }\n        });\n      }\n\n      lines = str.match(/\\n/g);\n\n      if (lines) {\n        line += lines.length;\n        last = str.lastIndexOf(\"\\n\");\n        column = str.length - last;\n      } else {\n        column = column + str.length;\n      }\n\n      if (node && node.source && node.source.end && type != 'start') {\n        this$0.map.addMapping({\n          source: this$0.sourcePath(node),\n          original: {\n            line: node.source.end.line,\n            column: node.source.end.column\n          },\n          generated: {\n            line: line,\n            column: column\n          }\n        });\n      }\n    };\n\n    this.root.stringify(builder);\n  }; // Return Result object with or without map\n\n\n  MapGenerator.prototype.generate = function () {\n    this.clearAnnotation();\n\n    if (this.isMap()) {\n      return this.generateMap();\n    } else {\n      return [this.root.toString()];\n    }\n  };\n\n  return MapGenerator;\n}();\n\nmodule.exports = MapGenerator;","map":null,"metadata":{},"sourceType":"script"}