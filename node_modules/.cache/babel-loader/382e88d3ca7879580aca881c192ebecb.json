{"ast":null,"code":"var Declaration = require('./declaration');\n\nvar Comment = require('./comment');\n\nvar AtRule = require('./at-rule');\n\nvar Result = require('./result');\n\nvar Rule = require('./rule');\n\nvar Root = require('./root'); // List of functions to process CSS\n\n\nvar PostCSS = function () {\n  var DP$0 = Object.defineProperty;\n  \"use strict\";\n\n  function PostCSS() {\n    var processors = arguments[0];\n    if (processors === void 0) processors = [];\n    this.processors = processors;\n  }\n\n  DP$0(PostCSS, \"prototype\", {\n    \"configurable\": false,\n    \"enumerable\": false,\n    \"writable\": false\n  }); // Add another function to CSS processors\n\n  PostCSS.prototype.use = function (processor) {\n    this.processors.push(processor);\n    return this;\n  }; // Process CSS throw installed processors\n\n\n  PostCSS.prototype.process = function (css) {\n    var S_ITER$0 = typeof Symbol !== 'undefined' && Symbol.iterator || '@@iterator';\n\n    function GET_ITER$0(v) {\n      if (v) {\n        if (Array.isArray(v)) return 0;\n        var f;\n        if (typeof v === 'object' && typeof (f = v[S_ITER$0]) === 'function') return f.call(v);\n        if (v + '' === '[object Generator]') return v;\n      }\n\n      throw new Error(v + ' is not iterable');\n    }\n\n    ;\n    var $D$0;\n    var $D$1;\n    var $D$2;\n    var $D$3;\n    var opts = arguments[1];\n    if (opts === void 0) opts = {};\n    if (opts.map == 'inline') opts.map = {\n      inline: true\n    };\n    var parsed;\n\n    if (css instanceof Root) {\n      parsed = css;\n    } else if (css instanceof Result) {\n      parsed = css.root;\n    } else {\n      parsed = postcss.parse(css, opts);\n    }\n\n    $D$3 = this.processors;\n    $D$0 = GET_ITER$0($D$3);\n    $D$2 = $D$0 === 0;\n    $D$1 = $D$2 ? $D$3.length : void 0;\n\n    for (var processor; $D$2 ? $D$0 < $D$1 : !($D$1 = $D$0[\"next\"]())[\"done\"];) {\n      processor = $D$2 ? $D$3[$D$0++] : $D$1[\"value\"];\n      var returned = processor(parsed);\n      if (returned instanceof Root) parsed = returned;\n    }\n\n    ;\n    $D$0 = $D$1 = $D$2 = $D$3 = void 0;\n    return parsed.toResult(opts);\n  };\n\n  return PostCSS;\n}(); // Framework for CSS postprocessors\n//\n//   var processor = postcss(function (css) {\n//       // Change nodes in css\n//   });\n//   processor.process(css)\n\n\nvar postcss = function postcss() {\n  var SLICE$0 = Array.prototype.slice;\n  var processors = SLICE$0.call(arguments, 0);\n  return new PostCSS(processors);\n}; // Compile CSS to nodes\n\n\npostcss.parse = require('./parse'); // Nodes shortcuts\n\npostcss.comment = function (defaults) {\n  return new Comment(defaults);\n};\n\npostcss.atRule = function (defaults) {\n  return new AtRule(defaults);\n};\n\npostcss.decl = function (defaults) {\n  return new Declaration(defaults);\n};\n\npostcss.rule = function (defaults) {\n  return new Rule(defaults);\n};\n\npostcss.root = function (defaults) {\n  return new Root(defaults);\n};\n\nmodule.exports = postcss;","map":null,"metadata":{},"sourceType":"script"}