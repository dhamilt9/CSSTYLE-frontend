{"ast":null,"code":"var Declaration = require('./declaration');\n\nvar Container = require('./container');\n\nvar Comment = require('./comment');\n\nvar AtRule = require('./at-rule');\n\nvar Result = require('./result');\n\nvar Rule = require('./rule'); // Root of CSS\n\n\nvar Root = function (super$0) {\n  var DP$0 = Object.defineProperty;\n\n  var MIXIN$0 = function MIXIN$0(t, s) {\n    for (var p in s) {\n      if (s.hasOwnProperty(p)) {\n        DP$0(t, p, Object.getOwnPropertyDescriptor(s, p));\n      }\n    }\n\n    return t;\n  };\n\n  \"use strict\";\n\n  MIXIN$0(Root, super$0);\n\n  function Root(defaults) {\n    this.type = 'root';\n    this.rules = [];\n    super$0.call(this, defaults);\n  }\n\n  Root.prototype = Object.create(super$0.prototype, {\n    \"constructor\": {\n      \"value\": Root,\n      \"configurable\": true,\n      \"writable\": true\n    }\n  });\n  DP$0(Root, \"prototype\", {\n    \"configurable\": false,\n    \"enumerable\": false,\n    \"writable\": false\n  }); // Fix spaces on insert before first rule\n\n  Root.prototype.normalize = function (child, sample, type) {\n    var S_ITER$0 = typeof Symbol !== 'undefined' && Symbol.iterator || '@@iterator';\n\n    function GET_ITER$0(v) {\n      if (v) {\n        if (Array.isArray(v)) return 0;\n        var f;\n        if (typeof v === 'object' && typeof (f = v[S_ITER$0]) === 'function') return f.call(v);\n        if (v + '' === '[object Generator]') return v;\n      }\n\n      throw new Error(v + ' is not iterable');\n    }\n\n    ;\n    var $D$0;\n    var $D$1;\n    var $D$2;\n    var childs = super$0.prototype.normalize.call(this, child, sample, type);\n    $D$0 = GET_ITER$0(childs);\n    $D$2 = $D$0 === 0;\n    $D$1 = $D$2 ? childs.length : void 0;\n\n    for (child; $D$2 ? $D$0 < $D$1 : !($D$1 = $D$0[\"next\"]())[\"done\"];) {\n      child = $D$2 ? childs[$D$0++] : $D$1[\"value\"];\n\n      if (type == 'prepend') {\n        if (this.rules.length > 1) {\n          sample.before = this.rules[1].before;\n        } else {\n          sample.before = this.after;\n        }\n      } else {\n        if (this.rules.length > 1) {\n          child.before = sample.before;\n        } else {\n          child.before = this.after;\n        }\n      }\n    }\n\n    ;\n    $D$0 = $D$1 = $D$2 = void 0;\n    return childs;\n  }; // Stringify styles\n\n\n  Root.prototype.stringify = function (builder) {\n    this.stringifyContent(builder);\n    if (this.after) builder(this.after);\n  }; // Generate processing result with optional source map\n\n\n  Root.prototype.toResult = function () {\n    var opts = arguments[0];\n    if (opts === void 0) opts = {};\n    return new Result(this, opts);\n  };\n\n  return Root;\n}(Container.WithRules);\n\nmodule.exports = Root;","map":null,"metadata":{},"sourceType":"script"}