{"ast":null,"code":"var CssSyntaxError = require('./css-syntax-error');\n\nvar PreviousMap = require('./previous-map');\n\nvar Declaration = require('./declaration');\n\nvar Comment = require('./comment');\n\nvar AtRule = require('./at-rule');\n\nvar Root = require('./root');\n\nvar Rule = require('./rule');\n\nvar path = require('path');\n\nvar isSpace = /\\s/;\nvar sequence = 0; // CSS parser\n\nvar Parser = function () {\n  var DP$0 = Object.defineProperty;\n  \"use strict\";\n\n  function Parser(source) {\n    var opts = arguments[1];\n    if (opts === void 0) opts = {};\n    this.source = source.toString();\n    this.opts = opts;\n    sequence += 1;\n    this.id = (new Date().valueOf() * 10 + sequence).toString();\n    this.root = new Root();\n    this.current = this.root;\n    this.parents = [this.current];\n    this.type = 'rules';\n    this.types = [this.type];\n    this.pos = -1;\n    this.line = 1;\n    this.lines = [];\n    this.column = 0;\n    this.buffer = '';\n  }\n\n  DP$0(Parser, \"prototype\", {\n    \"configurable\": false,\n    \"enumerable\": false,\n    \"writable\": false\n  });\n\n  Parser.prototype.loop = function () {\n    this.next = this.source[0];\n    var length = this.source.length - 1;\n\n    while (this.pos < length) {\n      this.move();\n      this.nextLetter();\n    }\n\n    this.endFile();\n  };\n\n  Parser.prototype.setMap = function () {\n    var map = new PreviousMap(this.root, this.opts, this.id);\n\n    if (map.text) {\n      this.root.prevMap = map;\n      this.root.eachInside(function (i) {\n        return i.source.map = map;\n      });\n    }\n  };\n\n  Parser.prototype.nextLetter = function () {\n    return this.inString() || this.inComment() || this.isComment() || this.isString() || this.isWrong() || this.inAtrule() || this.isAtrule() || this.isBlockEnd() || this.inSelector() || this.isSelector() || this.inProperty() || this.isProperty() || this.inValue();\n  }; // Parsers\n\n\n  Parser.prototype.inString = function (close) {\n    if (this.quote) {\n      if (this.escape && !close) {\n        this.escape = false;\n      } else if (this.letter == '\\\\') {\n        this.escape = true;\n      } else if (this.letter == this.quote || close) {\n        this.quote = undefined;\n      }\n\n      this.trimmed += this.letter;\n      return true;\n    }\n  };\n\n  Parser.prototype.isString = function () {\n    if (this.letter == '\"' || this.letter == \"'\") {\n      this.quote = this.letter;\n      this.quotePos = {\n        line: this.line,\n        column: this.column\n      };\n      this.trimmed += this.letter;\n      return true;\n    }\n  };\n\n  Parser.prototype.inComment = function (close) {\n    var $D$0;\n\n    if (this.inside('comment')) {\n      if (close || this.letter == '*' && this.next == '/') {\n        var text, left, right;\n        text = ($D$0 = this.startSpaces(this.prevBuffer()))[0], left = $D$0[1], $D$0;\n        text = ($D$0 = this.endSpaces(text))[0], right = $D$0[1], $D$0;\n        this.current.text = text;\n        this.current.left = left;\n        this.current.right = right;\n        this.move();\n        this.pop();\n        ;\n        $D$0 = void 0;\n      }\n\n      return true;\n    } else if (this.inside('value-comment')) {\n      if (close || this.letter == '*' && this.next == '/') {\n        this.popType();\n        this.move();\n      }\n\n      return true;\n    }\n  };\n\n  Parser.prototype.isComment = function () {\n    if (this.letter == '/' && this.next == '*') {\n      if (this.inside('rules') || this.inside('decls')) {\n        this.init(new Comment());\n        this.addType('comment');\n        this.move();\n        this.buffer = '';\n      } else {\n        this.commentPos = {\n          line: this.line,\n          column: this.column\n        };\n        this.addType('value-comment');\n        this.move();\n        return true;\n      }\n    }\n  };\n\n  Parser.prototype.isWrong = function () {\n    if (this.letter == '{') {\n      if (this.inside('decls') || this.inside('value')) {\n        this.error(\"Unexpected {\");\n      }\n    }\n\n    if (this.inside('prop')) {\n      if (this.letter == '}' || this.letter == ';') {\n        if (this.opts.safe) {\n          var string = this.current.before + this.buffer;\n          this.current.parent.decls.pop();\n          this.pop();\n          this.buffer = string;\n          this.semicolon = this.prevSemicolon;\n        } else {\n          this.error('Missing property value');\n        }\n      }\n    }\n  };\n\n  Parser.prototype.isAtrule = function () {\n    if (this.letter == '@' && this.inside('rules')) {\n      this.init(new AtRule());\n      this.current.name = '';\n      this.addType('atrule-name');\n      return true;\n    }\n  };\n\n  Parser.prototype.inAtrule = function (close) {\n    var $D$1;\n\n    if (this.inside('atrule-name')) {\n      if (this.space()) {\n        this.checkAtruleName();\n        this.buffer = this.buffer.substr(this.current.name.length);\n        this.trimmed = '';\n        this.setType('atrule-param');\n      } else if (this.letter == ';' || this.letter == '{' || close) {\n        this.current.between = '';\n        this.checkAtruleName();\n        this.endAtruleParams();\n      } else {\n        this.current.name += this.letter;\n      }\n\n      return true;\n    } else if (this.inside('atrule-param')) {\n      if (this.letter == ';' || this.letter == '{' || close) {\n        var raw, left, right;\n        raw = ($D$1 = this.startSpaces(this.prevBuffer()))[0], left = $D$1[1], $D$1;\n        raw = ($D$1 = this.endSpaces(raw))[0], right = $D$1[1], $D$1;\n        this.raw('params', this.trimmed.trim(), raw);\n\n        if (this.current.params) {\n          this.current.afterName = left;\n          this.current.between = right;\n        } else {\n          this.current.afterName = '';\n          this.current.between = left + right;\n        }\n\n        this.endAtruleParams();\n        ;\n        $D$1 = void 0;\n      } else {\n        this.trimmed += this.letter;\n      }\n\n      return true;\n    }\n  };\n\n  Parser.prototype.inSelector = function () {\n    var $D$2;\n\n    if (this.inside('selector')) {\n      if (this.letter == '{') {\n        var raw, spaces;\n        raw = ($D$2 = this.endSpaces(this.prevBuffer()))[0], spaces = $D$2[1], $D$2;\n        this.raw('selector', this.trimmed.trim(), raw);\n        this.current.between = spaces;\n        this.semicolon = false;\n        this.buffer = '';\n        this.setType('decls');\n        ;\n        $D$2 = void 0;\n      } else {\n        this.trimmed += this.letter;\n      }\n\n      return true;\n    }\n  };\n\n  Parser.prototype.isSelector = function () {\n    if (!this.space() && this.inside('rules')) {\n      this.init(new Rule());\n\n      if (this.letter == '{') {\n        this.addType('decls');\n        this.current.selector = '';\n        this.current.between = '';\n        this.semicolon = false;\n        this.buffer = '';\n      } else {\n        this.addType('selector');\n        this.buffer = this.letter;\n        this.trimmed = this.letter;\n      }\n\n      return true;\n    }\n  };\n\n  Parser.prototype.isBlockEnd = function (close) {\n    var this$0 = this;\n\n    if (this.letter == '}' || close) {\n      if (this.parents.length == 1) {\n        if (!this.opts.safe) {\n          this.error('Unexpected }');\n        }\n      } else {\n        if (this.inside('value')) {\n          this.fixEnd(function () {\n            return this$0.inValue('close');\n          });\n        } else if (this.inside('prop') && this.opts.safe) {\n          this.inProperty('close');\n        } else {\n          if (this.semicolon) this.current.semicolon = true;\n          this.current.after = this.prevBuffer();\n        }\n\n        this.pop();\n      }\n\n      return true;\n    }\n  };\n\n  Parser.prototype.inProperty = function (close) {\n    if (this.inside('prop')) {\n      if (this.letter == ':' || close) {\n        if (this.buffer[0] == '*' || this.buffer[0] == '_') {\n          this.current.before += this.buffer[0];\n          this.trimmed = this.trimmed.substr(1);\n          this.buffer = this.buffer.substr(1);\n        }\n\n        this.current.prop = this.trimmed.trim();\n        var length = this.current.prop.length;\n        this.current.between = this.prevBuffer().substr(length);\n        this.buffer = '';\n\n        if (close) {\n          this.current.value = '';\n          this.pop();\n        } else {\n          this.setType('value');\n        }\n\n        this.trimmed = '';\n      } else if (this.letter == '{') {\n        this.error('Unexpected { in decls');\n      } else {\n        this.trimmed += this.letter;\n      }\n\n      return true;\n    }\n  };\n\n  Parser.prototype.isProperty = function () {\n    if (this.inside('decls') && !this.space() && this.letter != ';') {\n      this.init(new Declaration());\n      this.addType('prop');\n      this.buffer = this.letter;\n      this.trimmed = this.letter;\n      this.prevSemicolon = this.semicolon;\n      this.semicolon = false;\n      return true;\n    }\n  };\n\n  Parser.prototype.inValue = function (close) {\n    var $D$3;\n\n    if (this.inside('value')) {\n      if (this.letter == '(') {\n        this.inBrackets = true;\n      } else if (this.inBrackets && this.letter == ')') {\n        this.inBrackets = false;\n      }\n\n      if (this.letter == ';' && !this.inBrackets || close) {\n        if (this.letter == ';') this.semicolon = true;\n        var raw, spaces;\n        raw = ($D$3 = this.startSpaces(this.prevBuffer()))[0], spaces = $D$3[1], $D$3;\n        var trim = this.trimmed.trim();\n\n        if (raw.indexOf('!important') != -1) {\n          var match = raw.match(/\\s+!important\\s*$/);\n\n          if (match) {\n            this.current.important = true;\n            this.current._important = match[0];\n            raw = raw.slice(0, -match[0].length);\n            trim = trim.replace(/\\s+!important$/, '');\n          }\n        }\n\n        this.raw('value', trim, raw);\n        this.current.between += ':' + spaces;\n        this.pop();\n        ;\n        $D$3 = void 0;\n      } else {\n        this.trimmed += this.letter;\n      }\n\n      return true;\n    }\n  };\n\n  Parser.prototype.endFile = function () {\n    var this$0 = this;\n\n    if (this.inside('atrule-param') || this.inside('atrule-name')) {\n      this.fixEnd(function () {\n        return this$0.inAtrule('close');\n      });\n    }\n\n    if (this.inside('comment') || this.inside('value-comment')) {\n      if (this.opts.safe) {\n        this.buffer += '/';\n        this.inComment('close');\n        this.closeBlocks();\n      } else {\n        if (this.inside('comment')) {\n          this.error('Unclosed comment', this.current.source.start);\n        } else {\n          this.error('Unclosed comment', this.commentPos);\n        }\n      }\n    } else if (this.parents.length > 1) {\n      if (this.opts.safe) {\n        this.closeBlocks();\n      } else {\n        this.error('Unclosed block', this.current.source.start);\n      }\n    } else if (this.quote) {\n      if (this.opts.safe) {\n        this.inString('close');\n        this.closeBlocks();\n      } else {\n        this.error('Unclosed quote', this.quotePos);\n      }\n    } else {\n      this.root.after = this.buffer;\n    }\n  }; // Helpers\n\n\n  Parser.prototype.error = function (message) {\n    var pos = arguments[1];\n    if (pos === void 0) pos = {\n      line: this.line,\n      column: this.column\n    };\n    throw new CssSyntaxError(message, this.source, pos, this.opts.from);\n  };\n\n  Parser.prototype.move = function () {\n    this.pos += 1;\n    this.column += 1;\n    this.letter = this.next;\n    this.next = this.source[this.pos + 1];\n    this.buffer += this.letter;\n\n    if (this.letter == \"\\n\") {\n      this.lines[this.line] = this.column - 1;\n      this.line += 1;\n      this.column = 0;\n    }\n  };\n\n  Parser.prototype.prevBuffer = function () {\n    return this.buffer.slice(0, -1);\n  };\n\n  Parser.prototype.inside = function (type) {\n    return this.type == type;\n  };\n\n  Parser.prototype.space = function () {\n    return this.letter.trim() === '';\n  };\n\n  Parser.prototype.init = function (node) {\n    this.current.push(node);\n    this.parents.push(node);\n    this.current = node;\n    this.current.source = {\n      start: {\n        line: this.line,\n        column: this.column\n      },\n      content: this.source\n    };\n\n    if (this.opts.from) {\n      this.current.source.file = path.resolve(this.opts.from);\n    } else {\n      this.current.source.id = this.id;\n    }\n\n    this.current.before = this.buffer.slice(0, -1);\n    this.buffer = '';\n  };\n\n  Parser.prototype.raw = function (prop, value, origin) {\n    this.current[prop] = value;\n\n    if (value != origin) {\n      this.current['_' + prop] = {\n        value: value,\n        raw: origin\n      };\n    }\n  };\n\n  Parser.prototype.fixEnd = function (callback) {\n    var start, after;\n\n    if (this.letter == '}') {\n      start = this.buffer.search(/\\s*\\}$/);\n      after = this.buffer.slice(start, -1);\n    } else {\n      start = this.buffer.search(/\\s*$/);\n      after = this.buffer.substr(start);\n    }\n\n    this.buffer = this.buffer.substr(0, start + 1);\n    var el = this.current;\n    callback.apply(this);\n    var lines = after.match(/\\n/g);\n\n    if (lines) {\n      el.source.end.line -= lines.length;\n      var all = this.lines[el.source.end.line];\n      var last = after.indexOf(\"\\n\");\n      if (last == -1) last = after.length;\n      el.source.end.column = all - last;\n    } else {\n      el.source.end.column -= after.length;\n    }\n\n    this.current.after = after;\n    this.buffer = after;\n  };\n\n  Parser.prototype.pop = function () {\n    this.current.source.end = {\n      line: this.line,\n      column: this.column\n    };\n    this.popType();\n    this.parents.pop();\n    this.current = this.parents[this.parents.length - 1];\n    this.buffer = '';\n  };\n\n  Parser.prototype.addType = function (type) {\n    this.types.push(type);\n    this.type = type;\n  };\n\n  Parser.prototype.setType = function (type) {\n    this.types[this.types.length - 1] = type;\n    this.type = type;\n  };\n\n  Parser.prototype.popType = function () {\n    this.types.pop();\n    this.type = this.types[this.types.length - 1];\n  };\n\n  Parser.prototype.atruleType = function () {\n    var name = this.current.name.toLowerCase();\n\n    if (name == 'page' || name == 'font-face') {\n      return 'decls';\n    } else if (name.slice(-8) == 'viewport') {\n      return 'decls';\n    } else {\n      return 'rules';\n    }\n  };\n\n  Parser.prototype.endAtruleParams = function () {\n    if (this.letter == '{') {\n      var type = this.atruleType();\n      this.current.addMixin(type);\n      this.setType(type);\n      this.buffer = '';\n    } else {\n      if (this.letter == ';') this.current.semicolon = true;\n      this.pop();\n    }\n  };\n\n  Parser.prototype.checkAtruleName = function () {\n    if (this.current.name === '') this.error('At-rule without name');\n  };\n\n  Parser.prototype.startSpaces = function (string) {\n    var match = string.match(/^\\s+/);\n\n    if (match) {\n      var pos = match[0].length;\n      return [string.substr(pos), match[0]];\n    } else {\n      return [string, ''];\n    }\n  };\n\n  Parser.prototype.endSpaces = function (string) {\n    var match = string.match(/\\s+$/);\n\n    if (match) {\n      var pos = match[0].length;\n      return [string.slice(0, -pos), match[0]];\n    } else {\n      return [string, ''];\n    }\n  };\n\n  Parser.prototype.closeBlocks = function () {\n    for (var i = 0; i < this.parents.length; i++) {\n      this.buffer += '{';\n      this.isBlockEnd('close');\n    }\n  };\n\n  return Parser;\n}();\n\nmodule.exports = function (source) {\n  var opts = arguments[1];\n  if (opts === void 0) opts = {};\n  if (opts.map == 'inline') opts.map = {\n    inline: true\n  };\n  var parser = new Parser(source, opts);\n  parser.loop();\n  parser.setMap();\n  return parser.root;\n};","map":null,"metadata":{},"sourceType":"script"}