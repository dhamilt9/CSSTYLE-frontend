{"ast":null,"code":"// Recursivly clone objects\nvar clone = function clone(obj, parent) {\n  if (typeof obj != 'object') return obj;\n  var cloned = new obj.constructor();\n\n  for (var name in obj) {\n    if (!obj.hasOwnProperty(name)) continue;\n    var value = obj[name];\n\n    if (name == 'parent' && typeof value == 'object') {\n      if (parent) cloned[name] = parent;\n    } else if (name == 'source') {\n      cloned[name] = value;\n    } else if (value instanceof Array) {\n      cloned[name] = value.map(function (i) {\n        return clone(i, cloned);\n      });\n    } else {\n      cloned[name] = clone(value, cloned);\n    }\n  }\n\n  return cloned;\n}; // Is `obj` has all keys from `keys`. Return `false` of object with keys from\n// `keys` and values from `obj`.\n\n\nvar keys = function keys(obj, _keys) {\n  var all = {};\n\n  for (var key in _keys) {\n    if (typeof obj[key] == 'undefined') {\n      return false;\n    } else {\n      all[key] = obj[key];\n    }\n  }\n\n  return all;\n}; // Some common methods for all CSS nodes\n\n\nvar Node = function () {\n  var DP$0 = Object.defineProperty;\n  \"use strict\";\n\n  function Node() {\n    var defaults = arguments[0];\n    if (defaults === void 0) defaults = {};\n\n    for (var name in defaults) {\n      this[name] = defaults[name];\n    }\n  }\n\n  DP$0(Node, \"prototype\", {\n    \"configurable\": false,\n    \"enumerable\": false,\n    \"writable\": false\n  }); // Remove this node from parent\n  //\n  //   decl.removeSelf();\n  //\n  // Note, that removing by index is faster:\n  //\n  //   rule.each( (decl, i) => rule.remove(i) );\n\n  Node.prototype.removeSelf = function () {\n    if (this.parent) {\n      this.parent.remove(this);\n    }\n\n    return this;\n  }; // Return CSS string of current node\n  //\n  //   decl.toString(); //=> \"  color: black\"\n\n\n  Node.prototype.toString = function () {\n    var result = '';\n\n    var builder = function builder(str) {\n      return result += str;\n    };\n\n    this.stringify(builder);\n    return result;\n  }; // Clone current node\n  //\n  //   rule.append( decl.clone() );\n  //\n  // You can override properties while cloning:\n  //\n  //   rule.append( decl.clone({ value: '0' }) );\n\n\n  Node.prototype.clone = function () {\n    var overrides = arguments[0];\n    if (overrides === void 0) overrides = {};\n    var cloned = clone(this);\n\n    for (var name in overrides) {\n      cloned[name] = overrides[name];\n    }\n\n    return cloned;\n  }; // Remove `parent` node on cloning to fix circular structures\n\n\n  Node.prototype.toJSON = function () {\n    var fixed = {};\n\n    for (var name in this) {\n      if (!this.hasOwnProperty(name)) continue;\n      if (name == 'parent') continue;\n      var value = this[name];\n\n      if (value instanceof Array) {\n        fixed[name] = value.map(function (i) {\n          return typeof i == 'object' && i.toJSON ? i.toJSON() : i;\n        });\n      } else if (typeof value == 'object' && value.toJSON) {\n        fixed[name] = value.toJSON();\n      } else {\n        fixed[name] = value;\n      }\n    }\n\n    return fixed;\n  }; // Default code style\n\n\n  Node.prototype.defaultStyle = function () {\n    return {};\n  }; // Allow to split node with same type by other critera.\n  // For example, to use different style for bodiless at-rules.\n\n\n  Node.prototype.styleType = function () {\n    return this.type;\n  }; // Copy code style from first node with same type\n\n\n  Node.prototype.style = function () {\n    var this$0 = this;\n    var type = this.styleType();\n    var defaults = this.defaultStyle(type);\n    var all = keys(this, defaults);\n    if (all) return all;\n    var styled = defaults;\n\n    if (this.parent) {\n      var root = this;\n\n      while (root.parent) {\n        root = root.parent;\n      }\n\n      if (!root.styleCache) root.styleCache = {};\n\n      if (root.styleCache[type]) {\n        styled = root.styleCache[type];\n      } else {\n        root.eachInside(function (another) {\n          if (another.styleType() != type) return;\n          if (this$0 == another) return;\n          all = keys(another, styled);\n\n          if (all) {\n            styled = all;\n            return false;\n          }\n        });\n        root.styleCache[type] = styled;\n      }\n    }\n\n    var merge = {};\n\n    for (var key in styled) {\n      if (typeof this[key] == 'undefined') {\n        merge[key] = styled[key];\n      } else {\n        merge[key] = this[key];\n      }\n    }\n\n    return merge;\n  }; // Use raw value if origin was not changed\n\n\n  Node.prototype.stringifyRaw = function (prop) {\n    var value = this[prop];\n    var raw = this['_' + prop];\n\n    if (raw && raw.value === value) {\n      return raw.raw;\n    } else {\n      return value;\n    }\n  };\n\n  return Node;\n}();\n\nmodule.exports = Node;","map":null,"metadata":{},"sourceType":"script"}