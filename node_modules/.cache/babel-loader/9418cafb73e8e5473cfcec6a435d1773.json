{"ast":null,"code":"(function () {\n  var Processor, Value, utils, vendor;\n  vendor = require('postcss/lib/vendor');\n  Value = require('./value');\n  utils = require('./utils');\n\n  Processor = function () {\n    function Processor(prefixes) {\n      this.prefixes = prefixes;\n    }\n\n    Processor.prototype.add = function (css) {\n      var keyframes, supports;\n      keyframes = this.prefixes.add['@keyframes'];\n      supports = this.prefixes.add['@supports'];\n      css.eachAtRule(function (_this) {\n        return function (rule) {\n          if (rule.name === 'keyframes') {\n            if (!_this.disabled(rule)) {\n              return keyframes != null ? keyframes.process(rule) : void 0;\n            }\n          } else if (rule.name === 'supports') {\n            if (!_this.disabled(rule)) {\n              return supports.process(rule);\n            }\n          }\n        };\n      }(this));\n      css.eachRule(function (_this) {\n        return function (rule) {\n          var selector, _i, _len, _ref, _results;\n\n          if (_this.disabled(rule)) {\n            return;\n          }\n\n          _ref = _this.prefixes.add.selectors;\n          _results = [];\n\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            selector = _ref[_i];\n\n            _results.push(selector.process(rule));\n          }\n\n          return _results;\n        };\n      }(this));\n      css.eachDecl(function (_this) {\n        return function (decl) {\n          var prefix;\n          prefix = _this.prefixes.add[decl.prop];\n\n          if (prefix && prefix.prefixes) {\n            if (!_this.disabled(decl)) {\n              return prefix.process(decl);\n            }\n          }\n        };\n      }(this));\n      return css.eachDecl(function (_this) {\n        return function (decl) {\n          var unprefixed, value, _i, _len, _ref;\n\n          if (_this.disabled(decl)) {\n            return;\n          }\n\n          unprefixed = _this.prefixes.unprefixed(decl.prop);\n          _ref = _this.prefixes.values('add', unprefixed);\n\n          for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n            value = _ref[_i];\n            value.process(decl);\n          }\n\n          return Value.save(_this.prefixes, decl);\n        };\n      }(this));\n    };\n\n    Processor.prototype.remove = function (css) {\n      var checker, _i, _len, _ref;\n\n      css.eachAtRule(function (_this) {\n        return function (rule, i) {\n          if (_this.prefixes.remove['@' + rule.name]) {\n            if (!_this.disabled(rule)) {\n              return rule.parent.remove(i);\n            }\n          }\n        };\n      }(this));\n      _ref = this.prefixes.remove.selectors;\n\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        checker = _ref[_i];\n        css.eachRule(function (_this) {\n          return function (rule, i) {\n            if (checker.check(rule)) {\n              if (!_this.disabled(rule)) {\n                return rule.parent.remove(i);\n              }\n            }\n          };\n        }(this));\n      }\n\n      return css.eachDecl(function (_this) {\n        return function (decl, i) {\n          var notHack, rule, unprefixed, _j, _len1, _ref1, _ref2;\n\n          if (_this.disabled(decl)) {\n            return;\n          }\n\n          rule = decl.parent;\n          unprefixed = _this.prefixes.unprefixed(decl.prop);\n\n          if ((_ref1 = _this.prefixes.remove[decl.prop]) != null ? _ref1.remove : void 0) {\n            notHack = _this.prefixes.group(decl).down(function (other) {\n              return other.prop === unprefixed;\n            });\n\n            if (notHack) {\n              if (decl.before.indexOf(\"\\n\") > -1) {\n                _this.reduceSpaces(decl);\n              }\n\n              rule.remove(i);\n              return;\n            }\n          }\n\n          _ref2 = _this.prefixes.values('remove', unprefixed);\n\n          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {\n            checker = _ref2[_j];\n\n            if (checker.check(decl.value)) {\n              rule.remove(i);\n              return;\n            }\n          }\n        };\n      }(this));\n    };\n\n    Processor.prototype.disabled = function (node) {\n      var status;\n\n      if (node._autoprefixerDisabled != null) {\n        return node._autoprefixerDisabled;\n      } else if (node.decls || node.rules) {\n        status = void 0;\n        node.each(function (i) {\n          if (i.type !== 'comment') {\n            return;\n          }\n\n          if (i.text === 'autoprefixer: off') {\n            status = false;\n            return false;\n          } else if (i.text === 'autoprefixer: on') {\n            status = true;\n            return false;\n          }\n        });\n        return node._autoprefixerDisabled = status != null ? !status : node.parent ? this.disabled(node.parent) : false;\n      } else {\n        return node._autoprefixerDisabled = this.disabled(node.parent);\n      }\n    };\n\n    Processor.prototype.reduceSpaces = function (decl) {\n      var diff, parts, prevMin, stop;\n      stop = false;\n      this.prefixes.group(decl).up(function (other) {\n        return stop = true;\n      });\n\n      if (stop) {\n        return;\n      }\n\n      parts = decl.before.split(\"\\n\");\n      prevMin = parts[parts.length - 1].length;\n      diff = false;\n      return this.prefixes.group(decl).down(function (other) {\n        var last;\n        parts = other.before.split(\"\\n\");\n        last = parts.length - 1;\n\n        if (parts[last].length > prevMin) {\n          if (diff === false) {\n            diff = parts[last].length - prevMin;\n          }\n\n          parts[last] = parts[last].slice(0, -diff);\n          return other.before = parts.join(\"\\n\");\n        }\n      });\n    };\n\n    return Processor;\n  }();\n\n  module.exports = Processor;\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}