{"ast":null,"code":"var DP$0 = Object.defineProperty;\n\nvar MIXIN$0 = function MIXIN$0(t, s) {\n  for (var p in s) {\n    if (s.hasOwnProperty(p)) {\n      DP$0(t, p, Object.getOwnPropertyDescriptor(s, p));\n    }\n  }\n\n  return t;\n};\n\nvar Node = require('./node');\n\nvar Declaration = require('./declaration'); // CSS node, that contain another nodes (like at-rules or rules with selectors)\n\n\nvar Container = function (super$0) {\n  \"use strict\";\n\n  function Container() {\n    super$0.apply(this, arguments);\n  }\n\n  MIXIN$0(Container, super$0);\n  Container.prototype = Object.create(super$0.prototype, {\n    \"constructor\": {\n      \"value\": Container,\n      \"configurable\": true,\n      \"writable\": true\n    },\n    first: {\n      \"get\": first$get$0,\n      \"configurable\": true,\n      \"enumerable\": true\n    },\n    last: {\n      \"get\": last$get$0,\n      \"configurable\": true,\n      \"enumerable\": true\n    },\n    list: {\n      \"get\": list$get$0,\n      \"configurable\": true,\n      \"enumerable\": true\n    }\n  });\n  DP$0(Container, \"prototype\", {\n    \"configurable\": false,\n    \"enumerable\": false,\n    \"writable\": false\n  });\n  var S_ITER$0 = typeof Symbol !== 'undefined' && Symbol.iterator || '@@iterator';\n\n  function GET_ITER$0(v) {\n    if (v) {\n      if (Array.isArray(v)) return 0;\n      var f;\n      if (typeof v === 'object' && typeof (f = v[S_ITER$0]) === 'function') return f.call(v);\n      if (v + '' === '[object Generator]') return v;\n    }\n\n    throw new Error(v + ' is not iterable');\n  }\n\n  ; // Stringify container childs\n\n  Container.prototype.stringifyContent = function (builder) {\n    if (!this.rules && !this.decls) return;\n    var i,\n        last = this.list.length - 1;\n\n    if (this.rules) {\n      for (i = 0; i < this.rules.length; i++) {\n        this.rules[i].stringify(builder, last == i);\n      }\n    } else if (this.decls) {\n      for (i = 0; i < this.decls.length; i++) {\n        this.decls[i].stringify(builder, last != i || this.semicolon);\n      }\n    }\n  }; // Generate default spaces before }\n\n\n  Container.prototype.defaultAfter = function () {\n    if (this.list.length === 0) {\n      return '';\n    } else {\n      var last = this.list[0].before;\n\n      if (typeof last != 'undefined' && last.indexOf(\"\\n\") == -1) {\n        return this.list[0].before;\n      } else {\n        return \"\\n\";\n      }\n    }\n  }; // Stringify node with start (for example, selector) and brackets block\n  // with child inside\n\n\n  Container.prototype.stringifyBlock = function (builder, start) {\n    var style = this.style();\n    if (this.before) builder(this.before);\n    builder(start, this, 'start');\n    this.stringifyContent(builder);\n    if (style.after) builder(style.after);\n    builder('}', this, 'end');\n  }; // Add child to end of list without any checks.\n  // Please, use `append()` method, `push()` is mostly for parser.\n\n\n  Container.prototype.push = function (child) {\n    child.parent = this;\n    this.list.push(child);\n    return this;\n  }; // Execute `callback` on every child element. First arguments will be child\n  // node, second will be index.\n  //\n  //   css.each( (rule, i) => {\n  //       console.log(rule.type + ' at ' + i);\n  //   });\n  //\n  // It is safe for add and remove elements to list while iterating:\n  //\n  //  css.each( (rule) => {\n  //      css.insertBefore( rule, addPrefix(rule) );\n  //      # On next iteration will be next rule, regardless of that\n  //      # list size was increased\n  //  });\n\n\n  Container.prototype.each = function (callback) {\n    if (!this.lastEach) this.lastEach = 0;\n    if (!this.indexes) this.indexes = {};\n    this.lastEach += 1;\n    var id = this.lastEach;\n    this.indexes[id] = 0;\n    var list = this.list;\n    if (!list) return;\n    var index, result;\n\n    while (this.indexes[id] < list.length) {\n      index = this.indexes[id];\n      result = callback(list[index], index);\n      if (result === false) break;\n      this.indexes[id] += 1;\n    }\n\n    delete this.indexes[id];\n    if (result === false) return false;\n  }; // Execute callback on every child in all rules inside.\n  //\n  // First argument will be child node, second will be index inside parent.\n  //\n  //   css.eachInside( (node, i) => {\n  //       console.log(node.type + ' at ' + i);\n  //   });\n  //\n  // Also as `each` it is safe of insert/remove nodes inside iterating.\n\n\n  Container.prototype.eachInside = function (callback) {\n    return this.each(function (child, i) {\n      var result = callback(child, i);\n\n      if (result !== false && child.eachInside) {\n        result = child.eachInside(callback);\n      }\n\n      if (result === false) return result;\n    });\n  }; // Execute callback on every declaration in all rules inside.\n  // It will goes inside at-rules recursivelly.\n  //\n  // First argument will be declaration node, second will be index inside\n  // parent rule.\n  //\n  //   css.eachDecl( (decl, i) => {\n  //       console.log(decl.prop + ' in ' + decl.parent.selector + ':' + i);\n  //   });\n  //\n  // Also as `each` it is safe of insert/remove nodes inside iterating.\n\n\n  Container.prototype.eachDecl = function (callback) {} // Different realization will be inside subclasses\n  // Execute callback on every block comment (only between rules\n  // and declarations, not inside selectors and values) in all rules inside.\n  //\n  // First argument will be comment node, second will be index inside\n  // parent rule.\n  //\n  //   css.eachComment( (comment, i) => {\n  //       console.log(comment.content + ' at ' + i);\n  //   });\n  //\n  // Also as `each` it is safe of insert/remove nodes inside iterating.\n  ;\n\n  Container.prototype.eachComment = function (callback) {\n    return this.eachInside(function (child, i) {\n      if (child.type == 'comment') {\n        var result = callback(child, i);\n        if (result === false) return result;\n      }\n    });\n  }; // Add child to container.\n  //\n  //   css.append(rule);\n  //\n  // You can add declaration by hash:\n  //\n  //   rule.append({ prop: 'color', value: 'black' });\n\n\n  Container.prototype.append = function (child) {\n    var $D$0;\n    var $D$1;\n    var $D$2;\n    var childs = this.normalize(child, this.list[this.list.length - 1]);\n    $D$0 = GET_ITER$0(childs);\n    $D$2 = $D$0 === 0;\n    $D$1 = $D$2 ? childs.length : void 0;\n\n    for (child; $D$2 ? $D$0 < $D$1 : !($D$1 = $D$0[\"next\"]())[\"done\"];) {\n      child = $D$2 ? childs[$D$0++] : $D$1[\"value\"];\n      this.list.push(child);\n    }\n\n    ;\n    $D$0 = $D$1 = $D$2 = void 0;\n    return this;\n  }; // Add child to beginning of container\n  //\n  //   css.prepend(rule);\n  //\n  // You can add declaration by hash:\n  //\n  //   rule.prepend({ prop: 'color', value: 'black' });\n\n\n  Container.prototype.prepend = function (child) {\n    var $D$3;\n    var $D$4;\n    var $D$5;\n    var childs = this.normalize(child, this.list[0], 'prepend').reverse();\n    $D$3 = GET_ITER$0(childs);\n    $D$5 = $D$3 === 0;\n    $D$4 = $D$5 ? childs.length : void 0;\n\n    for (child; $D$5 ? $D$3 < $D$4 : !($D$4 = $D$3[\"next\"]())[\"done\"];) {\n      child = $D$5 ? childs[$D$3++] : $D$4[\"value\"];\n      this.list.unshift(child);\n    }\n\n    ;\n    $D$3 = $D$4 = $D$5 = void 0;\n\n    for (var id in this.indexes) {\n      this.indexes[id] = this.indexes[id] + childs.length;\n    }\n\n    return this;\n  }; // Insert new `added` child before `exist`.\n  // You can set node object or node index (it will be faster) in `exist`.\n  //\n  //   css.insertAfter(1, rule);\n  //\n  // You can add declaration by hash:\n  //\n  //   rule.insertBefore(1, { prop: 'color', value: 'black' });\n\n\n  Container.prototype.insertBefore = function (exist, add) {\n    var $D$6;\n    var $D$7;\n    var $D$8;\n    exist = this.index(exist);\n    var type = exist === 0 ? 'prepend' : false;\n    var childs = this.normalize(add, this.list[exist], type).reverse();\n    $D$6 = GET_ITER$0(childs);\n    $D$8 = $D$6 === 0;\n    $D$7 = $D$8 ? childs.length : void 0;\n\n    for (var child; $D$8 ? $D$6 < $D$7 : !($D$7 = $D$6[\"next\"]())[\"done\"];) {\n      child = $D$8 ? childs[$D$6++] : $D$7[\"value\"];\n      this.list.splice(exist, 0, child);\n    }\n\n    ;\n    $D$6 = $D$7 = $D$8 = void 0;\n\n    for (var id in this.indexes) {\n      this.indexes[id] = this.indexes[id] + childs.length;\n    }\n\n    return this;\n  }; // Insert new `added` child after `exist`.\n  // You can set node object or node index (it will be faster) in `exist`.\n  //\n  //   css.insertAfter(1, rule);\n  //\n  // You can add declaration by hash:\n  //\n  //   rule.insertAfter(1, { prop: 'color', value: 'black' });\n\n\n  Container.prototype.insertAfter = function (exist, add) {\n    var $D$9;\n    var $D$10;\n    var $D$11;\n    exist = this.index(exist);\n    var childs = this.normalize(add, this.list[exist]).reverse();\n    $D$9 = GET_ITER$0(childs);\n    $D$11 = $D$9 === 0;\n    $D$10 = $D$11 ? childs.length : void 0;\n\n    for (var child; $D$11 ? $D$9 < $D$10 : !($D$10 = $D$9[\"next\"]())[\"done\"];) {\n      child = $D$11 ? childs[$D$9++] : $D$10[\"value\"];\n      this.list.splice(exist + 1, 0, child);\n    }\n\n    ;\n    $D$9 = $D$10 = $D$11 = void 0;\n\n    for (var id in this.indexes) {\n      this.indexes[id] = this.indexes[id] + childs.length;\n    }\n\n    return this;\n  }; // Remove `child` by index or node.\n  //\n  //   css.remove(2);\n\n\n  Container.prototype.remove = function (child) {\n    child = this.index(child);\n    this.list.splice(child, 1);\n\n    for (var id in this.indexes) {\n      var index = this.indexes[id];\n\n      if (index >= child) {\n        this.indexes[id] = index - 1;\n      }\n    }\n\n    return this;\n  }; // Return true if all childs return true in `condition`.\n  // Just shorcut for `list.every`.\n\n\n  Container.prototype.every = function (condition) {\n    return this.list.every(condition);\n  }; // Return true if one or more childs return true in `condition`.\n  // Just shorcut for `list.some`.\n\n\n  Container.prototype.some = function (condition) {\n    return this.list.some(condition);\n  }; // Return index of child\n\n\n  Container.prototype.index = function (child) {\n    if (typeof child == 'number') {\n      return child;\n    } else {\n      return this.list.indexOf(child);\n    }\n  }; // Shortcut to get first child\n\n\n  function first$get$0() {\n    if (!this.list) return undefined;\n    return this.list[0];\n  } // Shortcut to get first child\n\n\n  function last$get$0() {\n    if (!this.list) return undefined;\n    return this.list[this.list.length - 1];\n  } // Shortcut to get current list\n\n\n  function list$get$0() {\n    return this.rules || this.decls;\n  } // Normalize child before insert. Copy before from `sample`.\n\n\n  Container.prototype.normalize = function (child, sample) {\n    var $D$12;\n    var $D$13;\n    var $D$14;\n    var childs;\n\n    if (child.type == 'root') {\n      childs = child.rules;\n    } else if (Array.isArray(child)) {\n      childs = child.map(function (i) {\n        return i.clone();\n      });\n    } else {\n      if (child.parent) {\n        child = child.clone();\n      }\n\n      childs = [child];\n    }\n\n    $D$12 = GET_ITER$0(childs);\n    $D$14 = $D$12 === 0;\n    $D$13 = $D$14 ? childs.length : void 0;\n\n    for (child; $D$14 ? $D$12 < $D$13 : !($D$13 = $D$12[\"next\"]())[\"done\"];) {\n      child = $D$14 ? childs[$D$12++] : $D$13[\"value\"];\n      child.parent = this;\n\n      if (typeof child.before == 'undefined' && sample) {\n        child.before = sample.before;\n      }\n    }\n\n    ;\n    $D$12 = $D$13 = $D$14 = void 0;\n    return childs;\n  };\n\n  return Container;\n}(Node); // Container with another rules, like this.media at-rule\n\n\nContainer.WithRules = function (super$0) {\n  \"use strict\";\n\n  MIXIN$0(constructor$0, super$0);\n\n  function constructor$0(defaults) {\n    this.rules = [];\n    super$0.call(this, defaults);\n  }\n\n  constructor$0.prototype = Object.create(super$0.prototype, {\n    \"constructor\": {\n      \"value\": constructor$0,\n      \"configurable\": true,\n      \"writable\": true\n    }\n  });\n  DP$0(constructor$0, \"prototype\", {\n    \"configurable\": false,\n    \"enumerable\": false,\n    \"writable\": false\n  }); // Execute `callback` on every declaration in all rules inside.\n  // It will goes inside at-rules recursivelly.\n  //\n  // See documentation in `Container#eachDecl`.\n\n  constructor$0.prototype.eachDecl = function (callback) {\n    return this.each(function (child) {\n      if (child.eachDecl) {\n        var result = child.eachDecl(callback);\n        if (result === false) return result;\n      }\n    });\n  }; // Execute `callback` on every rule in conatiner and inside child at-rules.\n  //\n  // First argument will be rule node, second will be index inside parent.\n  //\n  //   css.eachRule( (rule, i) => {\n  //       if ( parent.type == 'atrule' ) {\n  //           console.log(rule.selector + ' in ' + rule.parent.name);\n  //       } else {\n  //           console.log(rule.selector + ' at ' + i);\n  //       }\n  //   });\n\n\n  constructor$0.prototype.eachRule = function (callback) {\n    return this.each(function (child, i) {\n      var result;\n\n      if (child.type == 'rule') {\n        result = callback(child, i);\n      } else if (child.eachRule) {\n        result = child.eachRule(callback);\n      }\n\n      if (result === false) return result;\n    });\n  }; // Execute `callback` on every at-rule in conatiner and inside at-rules.\n  //\n  // First argument will be at-rule node, second will be index inside parent.\n  //\n  //   css.eachAtRule( (atrule, parent, i) => {\n  //       if ( parent.type == 'atrule' ) {\n  //           console.log(atrule.name + ' in ' + atrule.parent.name);\n  //       } else {\n  //           console.log(atrule.name + ' at ' + i);\n  //       }\n  //   });\n\n\n  constructor$0.prototype.eachAtRule = function (callback) {\n    return this.eachInside(function (child, i) {\n      if (child.type == 'atrule') {\n        var result = callback(child, i);\n        if (result === false) return result;\n      }\n    });\n  };\n\n  return constructor$0;\n}(Container); // Container with another rules, like this.media at-rule\n\n\nContainer.WithDecls = function (super$0) {\n  \"use strict\";\n\n  MIXIN$0(constructor$1, super$0);\n\n  function constructor$1(defaults) {\n    this.decls = [];\n    super$0.call(this, defaults);\n  }\n\n  constructor$1.prototype = Object.create(super$0.prototype, {\n    \"constructor\": {\n      \"value\": constructor$1,\n      \"configurable\": true,\n      \"writable\": true\n    }\n  });\n  DP$0(constructor$1, \"prototype\", {\n    \"configurable\": false,\n    \"enumerable\": false,\n    \"writable\": false\n  }); // Allow to define new declaration as hash\n\n  constructor$1.prototype.normalize = function (child, sample, type) {\n    if (!child.type && !Array.isArray(child)) {\n      child = new Declaration(child);\n    }\n\n    return super$0.prototype.normalize.call(this, child, sample, type);\n  }; // Execute callback on every declaration.\n  //\n  // See documentation in `Container#eachDecl`.\n\n\n  constructor$1.prototype.eachDecl = function (callback) {\n    return this.each(function (child, i) {\n      if (child.type == 'decl') {\n        var result = callback(child, i);\n        if (result === false) return result;\n      }\n    });\n  };\n\n  return constructor$1;\n}(Container);\n\nmodule.exports = Container;","map":null,"metadata":{},"sourceType":"script"}