{"ast":null,"code":"(function () {\n  var Prefixes, Supports, Value, findCondition, findDecl, list, postcss, split, utils;\n  Prefixes = require('./prefixes');\n  Value = require('./value');\n  utils = require('./utils');\n  postcss = require('postcss');\n  list = require('postcss/lib/list');\n  split = /\\(\\s*([^\\(\\):]+)\\s*:([^\\)]+)/;\n  findDecl = /\\(\\s*([^\\(\\):]+)\\s*:\\s*([^\\)]+)\\s*\\)/g;\n  findCondition = /(not\\s*)?\\(\\s*([^\\(\\):]+)\\s*:\\s*([^\\)]+)\\s*\\)\\s*or\\s*/gi;\n\n  Supports = function () {\n    function Supports(all) {\n      this.all = all;\n    }\n\n    Supports.prototype.virtual = function (prop, value) {\n      var rule;\n      rule = postcss.parse('a{}').first;\n      rule.append({\n        prop: prop,\n        value: value,\n        before: ''\n      });\n      return rule;\n    };\n\n    Supports.prototype.prefixed = function (prop, value) {\n      var decl, prefixer, rule, _i, _j, _len, _len1, _ref, _ref1;\n\n      rule = this.virtual(prop, value);\n      prefixer = this.all.add[prop];\n\n      if (prefixer != null) {\n        if (typeof prefixer.process === \"function\") {\n          prefixer.process(rule.first);\n        }\n      }\n\n      _ref = rule.decls;\n\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        decl = _ref[_i];\n        _ref1 = this.all.values('add', prop);\n\n        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {\n          value = _ref1[_j];\n          value.process(decl);\n        }\n\n        Value.save(this.all, decl);\n      }\n\n      return rule.decls;\n    };\n\n    Supports.prototype.clean = function (params) {\n      return params.replace(findCondition, function (_this) {\n        return function (all) {\n          var check, checker, prop, unprefixed, value, _, _i, _len, _ref, _ref1, _ref2;\n\n          if (all.slice(0, 3).toLowerCase() === 'not') {\n            return all;\n          }\n\n          _ref = all.match(split), _ = _ref[0], prop = _ref[1], value = _ref[2];\n          unprefixed = _this.all.unprefixed(prop);\n\n          if ((_ref1 = _this.all.cleaner().remove[prop]) != null ? _ref1.remove : void 0) {\n            check = new RegExp('(\\\\(|\\\\s)' + utils.escapeRegexp(unprefixed) + ':');\n\n            if (check.test(params)) {\n              return '';\n            }\n          }\n\n          _ref2 = _this.all.cleaner().values('remove', unprefixed);\n\n          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n            checker = _ref2[_i];\n\n            if (checker.check(value)) {\n              return '';\n            }\n          }\n\n          return all;\n        };\n      }(this)).replace(/\\(\\s*\\((.*)\\)\\s*\\)/g, '($1)');\n    };\n\n    Supports.prototype.process = function (rule) {\n      rule.params = this.clean(rule.params);\n      return rule.params = rule.params.replace(findDecl, function (_this) {\n        return function (all, prop, value) {\n          var i, stringed;\n\n          stringed = function () {\n            var _i, _len, _ref, _results;\n\n            _ref = this.prefixed(prop, value);\n            _results = [];\n\n            for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n              i = _ref[_i];\n\n              _results.push(\"(\" + i.prop + \": \" + i.value + \")\");\n            }\n\n            return _results;\n          }.call(_this);\n\n          if (stringed.length === 1) {\n            return stringed[0];\n          } else {\n            return '(' + stringed.join(' or ') + ')';\n          }\n        };\n      }(this));\n    };\n\n    return Supports;\n  }();\n\n  module.exports = Supports;\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}